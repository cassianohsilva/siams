<span class="badge badge-info">add</span>
<h4>add $s1,$s2,$s3</h4>
<h4>Soma o valor de $s1 ao $s2 e armazena no $s0<br/></h4>

<span class="badge badge-info">addu</span>
<h4>addu $s1,$s2,$s3</h4>
<h4>Soma o valor de $s1 ao $s2 e armazena no $s0 sem levar em conta o sinal<br/>

<span class="badge badge-info">xor</span>
<h4>xor $s0,$s1,$s2</h4>
<h4>Verifica bit a bit se $s1 e $s2 são 1 e 0 ou 0 e 1 então armazena 1 no $s0 se não armazena 0<br/></h4>

<span class="badge badge-info">sub</span>
<h4>sub $s0,$s1,$s2</h4>
<h4>Substrai o valor de $s1 ao $s2 e armazena no $s0<br/></h4>

<span class="badge badge-info">subu</span>
<h4>subu $s0,$s1,$s2</h4>
<h4>Substrai o valor de $s1 ao $s2 e armazena no $s0 sem utilizar sinal<br/></h4>

<span class="badge badge-info">and</span>
<h4>and $s0,$s1,$s2</h4>
<h4>Verifica bit a bit se $s1 e $s2 são 1 e 1 então armazena 1 no $s0 se não armazena 0<br/></h4>

<span class="badge badge-info">or</span>
<h4>or $s0,$s1,$s2</h4>
<h4>Verifica bit a bit se $s1 e $s2 se tem 1 então armazena 1 no $s0 se não armazena 0<br/></h4>

<span class="badge badge-info">nor</span>
<h4>nor $s0,ma$s1,$s2</h4>
<h4>Primeiro ela faz OR e depois ela nega e armazena em $s0<br/></h4>

<span class="badge badge-info">slt</span>
<h4>slt $s0,$s1,$s2</h4>
<h4>Verifica se $s1 é menor que $s2 então armazena 1 em $s0 senão armazena 0<br/></h4>

<span class="badge badge-info">sltu</span>
<h4>sltu $s0,$s1,$s2</h4>
<h4>Verifica se $s1 é menor que $s2 então armazena 1 $s0 senão armazena 0 sem levar em conta o sinal<br/></h4>

<span class="badge badge-info">sll</span>
<h4>sll $s0,$s1,10</h4>
<h4>Desloca todos os bits de $s1 n posições para a direita e armazena em $s0<br/></h4>

<span class="badge badge-info">srl</span>
<h4>slr $s0,$s1,10</h4>
<h4>Desloca todos os bits de $s1 n posições para a esquerda e armazena em $s0<br/></h4>

<span class="badge badge-info">j</span>
<h4>j label</h4>
<h4>Vai para o endereço armazenado no label<br/></h4>

<span class="badge badge-info">jr</span>
<h4>jr $ra</h4>
<h4>Usado em situações de switch<br/></h4>

<span class="badge badge-info">jal</span>
<h4>jal</h4>
<h4>Usado em procedimentos<br/></h4>

<span class="badge badge-info">beq</span>
<h4>beq $s0,$s1,LABEL</h4>
<h4>Vai para o endereço armazenado no label se $s0 for igual a $s1<br/></h4>

<span class="badge badge-info">bne</span>
<h4>bne $s0,$s1,LABEL</h4>
<h4>Vai para o endereço armazenado no label se $s0 for diferente de $s1<br/></h4>

<span class="badge badge-info">addi</span>
<h4>addi $s0,$s1,100</h4>
<h4>Adiciona o valor de $s1 a constante e armazena no $s0<br/></h4>

<span class="badge badge-info">addiu</span>
<h4>addiu $s0,$s1,100</h4>
<h4>Adiciona o valor de $s1 a constante e armazena no $s0 sem levar em conta o sinal<br/></h4>

<span class="badge badge-info">slti</span>
<h4>slti $s0,$s1,50</h4>
<h4>Verifica se $s1 é menor que a constante então armazena 1 em $s0 senão armazena 0<br/></h4>

<span class="badge badge-info">xori</span>
<h4>xori $s0,$s1,4</h4>
<h4>Verifica bit a bit se $s1 e a costante são 1 e 0 ou 0 e 1 então armazena 1 no $s0 se não armazena 0<br/></h4>

<span class="badge badge-info">sltiu</span>
<h4>sltiu $s0,$s1,25</h4>
<h4>Verifica se $s1 é menor que a constante então armazena 1 $s0 senão armazena 0 sem levar em conta o sinal<br/></h4>

<span class="badge badge-info">andi</span>
<h4>and $s0,$s1,25</h4>
<h4>Verifica bit a bit se $s1 e a constante são 1 e 1 então armazena 1 no $s0 se não armazena 0<br/></h4>

<span class="badge badge-info">ori</span>
<h4>ori $s0,$s1,25</h4>
<h4>Verifica bit a bit se $s1 e $a constante se tem 1 então armazena 1 no $s0 se não armazena 0<br/></h4>

<span class="badge badge-info">lw</span>
<h4>lw $s1, 0($s2)</h4>
<h4>Pega o endereço base em $s2, soma 0 unidades e armazena o valor dessa posiçao da memória em $s1<br/></h4>

<span class="badge badge-info">sw</span>
<h4>sw $s1, 0($s2)</h4>
<h4>Vai no endereço base em $s2, soma 0 byte e armazena o valor de $s1 nessa posição da memória<br/></h4>

<span class="badge badge-info">sb</span>
<h4>sb $s1, 0($s2)</h4>
<h4>Pega o endereço base em $s2, soma 0 unidades e armazena byte por byte o valor dessa posiçao da memória em $s1<br/></h4>

<span class="badge badge-info">lb</span>
<h4>lb $s1, 0($s2)</h4>
<h4>Vai no endereço base em $s2, soma 0 byte e armazena o valor byte por byte de $s1 nessa posição da memória<br/></h4>

<span class="badge badge-info">sh</span>
<h4>sh $s1, 0($s2)</h4>
<h4>Pega o endereço base em $s2, soma 0 unidades e armazena o valor de metade da palavra dessa posiçao da memória em $s1<br/></h4>

<span class="badge badge-info">lh</span>
<h4>lh $s1, 0($s2)</h4>
<h4>Vai no endereço base em $s2, soma 0 byte e armazena o valor de metade da palavra de $s1 nessa posição da memória<br/></h4>

<span class="badge badge-info">lbu</span>
<h4>lbu $s1, 0($s2)</h4>
<h4>Vai no endereço base em $s2, soma 0 byte e armazena o valor byte por byte de $s1 nessa posição da memória sem levar em consideração o sinal<br/></h4>

<span class="badge badge-info">lhu</span>
<h4>lhu $s1, 0($s2)</h4>
<h4>Vai no endereço base em $s2, soma 0 byte e armazena o valor de metade da palavra de $s1 nessa posição da memória sem levar em consideração o sinal<br/></h4>

<span class="badge badge-info">lui</span>
<h4>lui $s0,61</h4>
<h4>Armazena os 16 bits mais significativos e adiciona em $s0<br/></h4>